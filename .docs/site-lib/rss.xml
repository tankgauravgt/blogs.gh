<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[GT Notes]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>GT Notes</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 22 Aug 2025 15:10:08 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 22 Aug 2025 15:09:52 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[HuggingFace: LLM Course]]></title><description><![CDATA[
transformers
datasets
torch
The&nbsp;pipeline()&nbsp;function in the ðŸ¤— Transformers library simplifies using models by integrating preprocessing and postprocessing steps.from transformers import pipeline text = "Huggingface is awesome!" # sentiment analysis:
e2e_model = pipeline("sentiment-analysis")
e2e_model(text)
Tip
We can pass several sentences in one go!
e2e_model([ "I've been waiting for a HuggingFace course my whole life.", "I hate this so much!"
]) NLP Pipelines Vision pipelines Audio pipelines Multimodal pipelines Focus:&nbsp;Understanding context, generating embeddings.
Mechanism:&nbsp;Bidirectional attention (sees past &amp; future tokens).
Training:&nbsp;Masked Language Modeling (MLM).
Use Cases:&nbsp;Text classification, sentiment analysis, Named Entity Recognition (NER), question answering (understanding).
Examples:&nbsp;BERT, RoBERTa. Focus:&nbsp;Generating new text, predicting next token.
Mechanism:&nbsp;Unidirectional attention (sees only past tokens).
Training:&nbsp;Predicts next word in a sequence.
Use Cases:&nbsp;Text generation, summarization, chatbots, code generation.
Examples:&nbsp;GPT series, LLaMA, Claude. Focus:&nbsp;Transforming one sequence into another.
Mechanism:&nbsp;Encoder-Decoder architecture. Encoder processes input, Decoder generates output having influenced by input.
Training:&nbsp;Maps input sequence to output sequence.
Use Cases:&nbsp;Machine translation, abstractive summarization, text style transfer.
Examples:&nbsp;T5, BART, NMT models.
# Model: BaseAutoEncodingModel
BaseAutoEncodingModel( 'embedder': BaseAutoEncodingModelEmbedderModule(...), 'encoder': BaseAutoEncodingModelEncoderModule(...), 'pooler': BaseAutoEncodingModelPoolerModule(...)
)
# Module: BaseAutoEncodingModelEmbedder
BaseAutoEncodingModelEmbedder( 'word_emb': WordEmbedder(...), 'pos_emb': PositionEmbedder(...), 'tok_type_emb': TokenTypeEmbedder(...), 'layer_norm': LayerNorm(...), 'dropout': Dropout(...)
)
# Module: BaseAutoEncodingModelEncoder
BaseAutoEncodingModelEncoder( 'layers': ModuleList( 'layer': N x BaseAutoEncodingModelEncoderLayer( 'attention': BaseAutoEncodingModelAttention(...), 'intermediate': BaseAutoEncodingModelIntermediate(...), 'output': BaseAutoEncodingModelOutput(...) ) )
) # SubModule: BaseAutoEncodingModelAttention
BaseAutoEncodingModelAttention( 'self_attention': BaseAutoEncodingModelSelfAttention( 'Q': Linear(...), 'K': Linear(...), 'V': Linear(...), 'dropout': Dropout(...) ), 'self_output': BaseAutoEncodingModelSelfOutput( 'dense': Linear(...), 'layer_norm': LayerNorm(...), 'dropout': Dropout(...) ),
) # SubModule: BaseAutoEncodingModelIntermediate
BaseAutoEncodingModelIntermediate( 'dense': Linear(...), 'activation': Activation(...)
) # SubModule: BaseAutoEncodingModelOutput
BaseAutoEncodingModelOutput( 'dense': Linear(...), 'layer_norm': LayerNorm(...), 'dropout': Dropout(...) )
BaseAutoEncodingModelPooler( 'dense': Linear(...), 'activation': Activation(...)
)
import torch.functional as F
import torch.nn as nn
import transformers
import tokenizers
import torch
import os
import math
from torch.utils.data import TensorDataset, DataLoader
from tqdm import tqdm
import glob if os.path.exists("tokenizer.json"): tokenizer = tokenizers.Tokenizer.from_file("tokenizer.json")
else: tokenizer = tokenizers.SentencePieceUnigramTokenizer() tokenizer.train( files=['./notebooks/processed.hi', './notebooks/processed.en'], vocab_size=8000, show_progress=True, special_tokens=["[UNK]", "[PAD]", "[CLS]", "[SEP]", "[MASK]"] ) tokenizer.save("tokenizer.json") unk_token_id = tokenizer.token_to_id("[UNK]")
pad_token_id = tokenizer.token_to_id("[PAD]")
cls_token_id = tokenizer.token_to_id("[CLS]")
sep_token_id = tokenizer.token_to_id("[SEP]")
mask_token_id = tokenizer.token_to_id("[MASK]") class TranslationModelConfig(transformers.PretrainedConfig): model_type = "translation-hi2en" def __init__( self, vocab_size=8000, d_model=512, num_encoder_layers=6, num_decoder_layers=6, num_heads=8, dim_feedforward=512, dropout=0.1, pad_token_id=pad_token_id, eos_token_id=sep_token_id, decoder_start_token_id=cls_token_id, initializer_range=0.02, max_position_embeddings=512, **kwargs): super().__init__(pad_token_id=pad_token_id, eos_token_id=eos_token_id, **kwargs) self.vocab_size = vocab_size self.d_model = d_model self.num_encoder_layers = num_encoder_layers self.num_decoder_layers = num_decoder_layers self.num_heads = num_heads self.dim_feedforward = dim_feedforward self.dropout = dropout self.decoder_start_token_id = decoder_start_token_id self.initializer_range = initializer_range self.max_position_embeddings = max_position_embeddings class PositionalEncoding(nn.Module): def __init__(self, d_model, dropout = 0.1, max_len = 5000): super().__init__() self.dropout = nn.Dropout(p=dropout) position = torch.arange(max_len).unsqueeze(1) div_term = torch.exp(torch.arange(0, d_model, 2) * (-math.log(10000.0) / d_model)) pe = torch.zeros(max_len, d_model) pe[:, 0::2] = torch.sin(position * div_term) pe[:, 1::2] = torch.cos(position * div_term) self.register_buffer('pe', pe.unsqueeze(0)) def forward(self, x): seq_len = x.size(1) x = x + self.pe[:, :seq_len] return self.dropout(x) class TranslationModel(transformers.PreTrainedModel): def __init__(self, config): super().__init__(config) self.cfg = config self.src_embedding = nn.Embedding(config.vocab_size, config.d_model, padding_idx=config.pad_token_id) self.tgt_embedding = nn.Embedding(config.vocab_size, config.d_model, padding_idx=config.pad_token_id) self.positional_encoding = PositionalEncoding(config.d_model, config.dropout, config.max_position_embeddings) encoder_layer = nn.TransformerEncoderLayer( d_model=config.d_model, nhead=config.num_heads, dim_feedforward=config.dim_feedforward, dropout=config.dropout, batch_first=True ) self.encoder = nn.TransformerEncoder(encoder_layer, num_layers=config.num_encoder_layers) decoder_layer = nn.TransformerDecoderLayer( d_model=config.d_model, nhead=config.num_heads, dim_feedforward=config.dim_feedforward, dropout=config.dropout, batch_first=True ) self.decoder = nn.TransformerDecoder(decoder_layer, num_layers=config.num_decoder_layers) self.output_layer = nn.Linear(config.d_model, config.vocab_size) self.apply(self._init_weights) def _init_weights(self, module): if isinstance(module, nn.Linear): module.weight.data.normal_(mean=0.0, std=self.cfg.initializer_range) if module.bias is not None: module.bias.data.zero_() elif isinstance(module, nn.Embedding): module.weight.data.normal_(mean=0.0, std=self.cfg.initializer_range) if module.padding_idx is not None: module.weight.data[module.padding_idx].zero_() elif isinstance(module, nn.LayerNorm): module.bias.data.zero_() module.weight.data.fill_(1.0) def forward(self, src, tgt, src_mask=None, tgt_mask=None): max_len = self.cfg.max_position_embeddings if src.size(1) &gt; max_len: src = src[:, :max_len] if src_mask is not None: src_mask = src_mask[:, :max_len] if tgt.size(1) &gt; max_len: tgt = tgt[:, :max_len] if tgt_mask is not None and tgt_mask.size(0) &gt; max_len: tgt_mask = tgt_mask[:max_len, :max_len] src_emb = self.positional_encoding(self.src_embedding(src) * math.sqrt(self.cfg.d_model)) tgt_emb = self.positional_encoding(self.tgt_embedding(tgt) * math.sqrt(self.cfg.d_model)) memory = self.encoder(src_emb, src_key_padding_mask=src_mask) output = self.decoder(tgt_emb, memory, tgt_mask=tgt_mask, memory_key_padding_mask=src_mask) logits = self.output_layer(output) return logits model = TranslationModel(TranslationModelConfig()) device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")
model.to(device) optimizer = torch.optim.Adam(model.parameters(), lr=1e-4) criterion = nn.CrossEntropyLoss(ignore_index=pad_token_id) batch_size = 32
seq_len = 256 class PairedDataset(torch.utils.data.Dataset): def __init__(self, src_data, tgt_data): self.tokenizer = tokenizer assert len(src_data) == len(tgt_data), "Source and target data must have the same length." self.src_data = src_data self.tgt_data = tgt_data self.max_len = 512 def __len__(self): return len(self.src_data) def __getitem__(self, idx): src_ids = tokenizer.encode(self.src_data[idx]).ids tgt_ids = tokenizer.encode(self.tgt_data[idx]).ids if len(src_ids) &gt; self.max_len: src_ids = src_ids[:self.max_len] if len(tgt_ids) &gt; self.max_len: tgt_ids = tgt_ids[:self.max_len] return src_ids, tgt_ids dataset = PairedDataset( open('./notebooks/processed.hi', 'r').readlines(), open('./notebooks/processed.en', 'r').readlines()
) train_size = int(0.8 * len(dataset))
val_size = int(0.1 * len(dataset))
test_size = len(dataset) - train_size - val_size
train_dataset, val_dataset, test_dataset = torch.utils.data.random_split(dataset, [train_size, val_size, test_size]) train_dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True, collate_fn=lambda batch: ( torch.nn.utils.rnn.pad_sequence([torch.tensor(item[0])[:512] for item in batch], batch_first=True, padding_value=pad_token_id), torch.nn.utils.rnn.pad_sequence([torch.tensor(item[1])[:512] for item in batch], batch_first=True, padding_value=pad_token_id)
)) num_epochs = 500 checkpoint_dir = "checkpoints"
os.makedirs(checkpoint_dir, exist_ok=True) latest_checkpoint = None
checkpoints = sorted(glob.glob(os.path.join(checkpoint_dir, "checkpoint_epoch_*.pt")))
if checkpoints: latest_checkpoint = checkpoints[-1] start_epoch = 0
if latest_checkpoint is not None: print(f"Loading checkpoint from {latest_checkpoint} to resume training...") checkpoint = torch.load(latest_checkpoint, map_location=device) model.load_state_dict(checkpoint['model_state_dict']) optimizer.load_state_dict(checkpoint['optimizer_state_dict']) start_epoch = checkpoint['epoch'] print(f"Resuming from epoch {start_epoch}") print("\nStarting training loop on actual data...")
for epoch in range(start_epoch, num_epochs): model.train() total_loss = 0 for batch_idx, (src_batch, tgt_batch) in enumerate(tqdm(train_dataloader, ncols=80)): src_batch, tgt_batch = src_batch.to(device), tgt_batch.to(device) src_mask = (src_batch == pad_token_id).to(device) decoder_input = tgt_batch[:, :-1] target_labels = tgt_batch[:, 1:] decoder_input_seq_len = decoder_input.size(1) causal_tgt_mask = torch.triu(torch.ones(decoder_input_seq_len, decoder_input_seq_len), diagonal=1).bool().to(device) output_logits = model(src_batch, decoder_input, src_mask=src_mask, tgt_mask=causal_tgt_mask) loss = criterion(output_logits.view(-1, model.cfg.vocab_size), target_labels.reshape(-1)) optimizer.zero_grad() loss.backward() optimizer.step() total_loss += loss.item() avg_loss = total_loss / len(train_dataloader) print(f"Epoch {epoch+1}/{num_epochs}, Average Loss: {avg_loss:.4f}") checkpoint_path = os.path.join(checkpoint_dir, f"checkpoint_epoch_{epoch+1}.pt") torch.save({ 'epoch': epoch + 1, 'model_state_dict': model.state_dict(), 'optimizer_state_dict': optimizer.state_dict(), 'loss': avg_loss }, checkpoint_path) checkpoints = sorted(glob.glob(os.path.join(checkpoint_dir, "checkpoint_epoch_*.pt"))) if len(checkpoints) &gt; 2: os.remove(checkpoints[0]) print("\nTraining loop on actual data finished.")
print("If the 'Average Loss' is decreasing over epochs, your model is training!")
]]></description><link>machine-learning/huggingface-llm-course.html</link><guid isPermaLink="false">Machine Learning/HuggingFace - LLM Course.md</guid><pubDate>Thu, 31 Jul 2025 22:05:28 GMT</pubDate></item><item><title><![CDATA[Welcome to GT Notes!]]></title><description><![CDATA[Welcome to GT Notes!
<a data-tooltip-position="top" aria-label="Agentic AI/index" data-href="Agentic AI/index" href="agentic-ai/index.html" class="internal-link" target="_self" rel="noopener nofollow">Index: Agentic AI</a>
<br><a data-tooltip-position="top" aria-label="LeetCode Solutions/index" data-href="LeetCode Solutions/index" href="leetcode-solutions/index.html" class="internal-link" target="_self" rel="noopener nofollow">Index: LeetCode Solutions</a>
<br><a data-tooltip-position="top" aria-label="Machine Learning/index" data-href="Machine Learning/index" href="machine-learning/index.html" class="internal-link" target="_self" rel="noopener nofollow">Index: Machine Learning</a>
<br><a data-tooltip-position="top" aria-label="System Design/index" data-href="System Design/index" href="system-design/index.html" class="internal-link" target="_self" rel="noopener nofollow">Index: System Design</a>
]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Thu, 31 Jul 2025 10:11:47 GMT</pubDate></item><item><title><![CDATA[Agentic AI: Create MCP Client]]></title><description><![CDATA[
&lt;steps will go here&gt; sample reference: a
sample reference: b
]]></description><link>agentic-ai/ragged-notes/02-create-mcp-client.html</link><guid isPermaLink="false">Agentic AI/Ragged Notes/02-Create MCP Client.md</guid><pubDate>Thu, 31 Jul 2025 06:54:13 GMT</pubDate></item><item><title><![CDATA[Agentic AI: Create MCP Server]]></title><description><![CDATA[In this article, we will create an MCP server with "streamable-http" transport. The reason behind this selection is due to it's scalability, portability and ease of integration.Install uv package manager which is rust based and extremely fast compared to pip.curl -LsSf https://astral.sh/uv/install.sh | sh
Change working directory to an empty directory where the project will be bootstrapped. uv init # initialize new project
uv venv # create new python virtual environment (Optional)
source .venv/bin/activate # (use `.venv\Scripts\activate` for windows)
uv pip install fastmcp
from fastmcp import FastMCP
import asyncio # =========================================================
# Create MCP server:
# ========================================================= mcp = FastMCP() # =========================================================
# Define tools:
# ========================================================= @mcp.tool( name="add_numbers", description="The sum of the two input integers.", output_schema={ "type": "object", "properties": { "result": { "type": "integer", "description": "The sum of the two input integers." } }, "required": ["result"] }
)
async def add_numbers(a: int, b: int) -&gt; dict: """ Add two numbers and return the result. :param a int: The first integer to add. :param b int: The second integer to add. :return: A dictionary containing the sum of the two integers. """ return {"result": a + b} # =========================================================
# Run the server:
# ========================================================= if __name__ == "__main__": asyncio.run( mcp.run_async( transport="streamable-http", host="localhost", port=8000 ) )
MCP server will start running at http://localhost:8000/mcp]]></description><link>agentic-ai/ragged-notes/01-create-mcp-server.html</link><guid isPermaLink="false">Agentic AI/Ragged Notes/01-Create MCP Server.md</guid><pubDate>Thu, 31 Jul 2025 06:54:03 GMT</pubDate></item><item><title><![CDATA[Index: Agentic AI]]></title><description><![CDATA[
<a data-tooltip-position="top" aria-label="01-Create MCP Server" data-href="01-Create MCP Server" href="agentic-ai/ragged-notes/01-create-mcp-server.html" class="internal-link" target="_self" rel="noopener nofollow">Agentic AI: Create MCP Server</a>
<br><a data-tooltip-position="top" aria-label="02-Create MCP Client" data-href="02-Create MCP Client" href="agentic-ai/ragged-notes/02-create-mcp-client.html" class="internal-link" target="_self" rel="noopener nofollow">Agentic AI: Create MCP Client</a>
]]></description><link>agentic-ai/index.html</link><guid isPermaLink="false">Agentic AI/index.md</guid><pubDate>Thu, 31 Jul 2025 06:21:44 GMT</pubDate></item><item><title><![CDATA[0062: Unique Paths]]></title><description><![CDATA[class Solution: def uniquePaths(self, m, n): @cache def rec(rx, cx): if rx == m - 1 and cx == n - 1: return 0 if rx == m - 1: return 1 if cx == n - 1: return 1 count = 0 count = count + rec(rx + 1, cx) count = count + rec(rx, cx + 1) return count return rec(0, 0)
]]></description><link>leetcode-solutions/all-solutions/0062-unique-paths.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0062-Unique Paths.md</guid><pubDate>Thu, 31 Jul 2025 06:21:44 GMT</pubDate></item><item><title><![CDATA[0070: Climbing Stairs]]></title><description><![CDATA[from functools import lru_cache class Solution: def climbStairs(self, n): @cache def rec(k): if k &gt;= n: return 0 takeit = rec(k + 1) skipit = rec(k + 2) return 1 + takeit + skipit return rec(n)
]]></description><link>leetcode-solutions/all-solutions/0070-climbing-stairs.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0070-Climbing Stairs.md</guid><pubDate>Thu, 31 Jul 2025 06:21:44 GMT</pubDate></item><item><title><![CDATA[0091: Decode Ways]]></title><description><![CDATA[class Solution: def numDecodings(self, s): i2c = {str(1 + ix): chr(ix + ord('A')) for ix in range(26)} @cache def rec(ix): if ix == len(s): return 1 count = 0 for k, v in i2c.items(): if s[ix::].startswith(k): count = count + rec(ix + len(k)) return count return rec(0)
]]></description><link>leetcode-solutions/all-solutions/0091-decode-ways.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0091-Decode Ways.md</guid><pubDate>Thu, 31 Jul 2025 06:21:43 GMT</pubDate></item><item><title><![CDATA[0139: Word Break]]></title><description><![CDATA[class Solution: def wordBreak(self, s, wordDict): wdict = set(wordDict) w_max = len(max(*wdict, key=len)) @cache def rec(sx): if sx &gt;= len(s): return True flag = False for ws in range(1 + w_max): if s[sx:sx + ws] in wdict: flag = flag or rec(sx + ws) return flag return rec(0)
]]></description><link>leetcode-solutions/all-solutions/0139-word-break.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0139-Word Break.md</guid><pubDate>Thu, 31 Jul 2025 06:21:43 GMT</pubDate></item><item><title><![CDATA[0198: House Robber]]></title><description><![CDATA[from functools import lru_cache class Solution: def rob(self, nums): @lru_cache(maxsize=None) def rec(sx): if ix &gt;= len(nums): return 0 takeit = nums[sx] + rec(sx + 2) skipit = rec(sx + 1) return max(takeit, skipit) return rec(0)
]]></description><link>leetcode-solutions/all-solutions/0198-house-robber.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0198-House Robber.md</guid><pubDate>Thu, 31 Jul 2025 06:21:43 GMT</pubDate></item><item><title><![CDATA[0213: House Robber II]]></title><description><![CDATA[class Solution: def rob(self, nums): N = len(nums) @cache def rec(sx, ex): if sx &gt;= ex: return 0 takeit = nums[sx] + rec(sx + 2, ex) skipit = rec(sx + 1, ex) return max(takeit, skipit) return max(rec(0, N - 1), rec(1, N)) if N &gt; 1 else nums[0]
]]></description><link>leetcode-solutions/all-solutions/0213-house-robber-ii.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0213-House Robber II.md</guid><pubDate>Thu, 31 Jul 2025 06:21:43 GMT</pubDate></item><item><title><![CDATA[0322: Coin Change]]></title><description><![CDATA[class Solution: def coinChange(self, coins, amount): @cache def rec(n): if n &gt;= amount: return 0 if (n == amount) else float('inf') cmin = float('inf') for coin in coins: cmin = min(cmin, 1 + rec(n + coin)) return cmin out = rec(0) return out if out != float('inf') else -1
]]></description><link>leetcode-solutions/all-solutions/0322-coin-change.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0322-Coin Change.md</guid><pubDate>Thu, 31 Jul 2025 06:21:43 GMT</pubDate></item><item><title><![CDATA[0377: Combination Sum IV]]></title><description><![CDATA[from functools import lru_cache class Solution: def combinationSum4(self, nums, target): @lru_cache(maxsize=None) def rec(curr, tgt): if curr &gt;= tgt: return int(curr == tgt) total = 0 for n in nums: total = total + rec(curr + n, tgt) return total return rec(0, target)
]]></description><link>leetcode-solutions/all-solutions/0377-combination-sum-iv.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0377-Combination Sum IV.md</guid><pubDate>Thu, 31 Jul 2025 06:21:42 GMT</pubDate></item><item><title><![CDATA[Index: LeetCode Solutions]]></title><description><![CDATA[Personal coding problem tracker with solution links. A structured way to monitor progress and enhance problem-solving skills.]]></description><link>leetcode-solutions/index.html</link><guid isPermaLink="false">LeetCode Solutions/index.md</guid><pubDate>Thu, 31 Jul 2025 06:21:42 GMT</pubDate></item><item><title><![CDATA[Blind 75]]></title><link>leetcode-solutions/practice-sheets/blind-75.html</link><guid isPermaLink="false">LeetCode Solutions/Practice Sheets/Blind 75.md</guid><pubDate>Mon, 28 Jul 2025 06:58:24 GMT</pubDate></item><item><title><![CDATA[0152: Maximum Product Subarray]]></title><description><![CDATA[class Solution: def maxProduct(self, nums): out = cmin = cmax = nums[0] for n in nums[1:]: candidates = (n, cmin * n, cmax * n) cmax = max(candidates) cmin = min(candidates) out = max(out, cmax) return out
]]></description><link>leetcode-solutions/all-solutions/0152-maximum-product-subarray.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0152-Maximum Product Subarray.md</guid><pubDate>Mon, 28 Jul 2025 06:52:48 GMT</pubDate></item><item><title><![CDATA[1143: Longest Common Subsequence]]></title><description><![CDATA[class Solution: def longestCommonSubsequence(self, text1, text2): @cache def lcs(t1, t2): if t1 &gt;= len(text1): return 0 if t2 &gt;= len(text2): return 0 # take it: if text1[t1] == text2[t2]: return 1 + lcs(1 + t1, 1 + t2) # skip it: else: skip_t1 = lcs(1 + t1, t2) skip_t2 = lcs(t1, 1 + t2) return max(skip_t1, skip_t2) return lcs(0, 0)
]]></description><link>leetcode-solutions/all-solutions/1143-longest-common-subsequence.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/1143-Longest Common Subsequence.md</guid><pubDate>Mon, 28 Jul 2025 04:34:38 GMT</pubDate></item><item><title><![CDATA[0300: Longest Increasing Subsequence]]></title><description><![CDATA[class Solution: def lengthOfLIS(self, nums): N = len(nums) # Maximum of below iterations: # (sx + 1): [..., sx - 1] &lt;sx&gt; [sx + 1, ..., N - 1] # (sx + 2): [..., sx - 1] &lt;sx&gt; [sx + 2, ..., N - 1] # (sx + 3): ....................................... # (sx + N - 1): [..., sx - 1] &lt;sx&gt; [sx + N, ..., N - 1] @cache def rec(sx): if sx == N: return 0 cmax = 1 for ix in range(sx + 1, N, 1): if nums[ix] &gt; nums[sx]: cmax = max(cmax, 1 + rec(ix)) return cmax # Perform LIS starting from all indices: return max([rec(ix) for ix in range(N)])
]]></description><link>leetcode-solutions/all-solutions/0300-longest-increasing-subsequence.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0300-Longest Increasing Subsequence.md</guid><pubDate>Mon, 28 Jul 2025 04:34:27 GMT</pubDate></item><item><title><![CDATA[0190: Reverse Bits]]></title><description><![CDATA[class Solution: def reverseBits(self, n: int) -&gt; int: out = 0 for ix in range(31, -1, -1): out = (out &lt;&lt; 1) | (n &amp; 1) n = n &gt;&gt; 1 return out
]]></description><link>leetcode-solutions/all-solutions/0190-reverse-bits.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0190-Reverse Bits.md</guid><pubDate>Fri, 25 Jul 2025 08:56:47 GMT</pubDate></item><item><title><![CDATA[0268: Missing Number]]></title><description><![CDATA[class Solution: def missingNumber(self, nums): N = len(nums) return ((N * (N + 1)) // 2) - sum(nums)
]]></description><link>leetcode-solutions/all-solutions/0268-missing-number.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0268-Missing Number.md</guid><pubDate>Fri, 25 Jul 2025 08:17:18 GMT</pubDate></item><item><title><![CDATA[0347: Top K Frequent Elements]]></title><description><![CDATA[from collections import Counter class Solution: def topKFrequent(self, nums, k): freq = Counter(nums) buckets = [[] for _ in range(len(nums) + 1)] for num, count in freq.items(): buckets[count].append(num) res = [] for i in range(len(buckets) - 1, 0, -1): for num in buckets[i]: res.append(num) if len(res) == k: return res
]]></description><link>leetcode-solutions/all-solutions/0347-top-k-frequent-elements.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0347-Top K Frequent Elements.md</guid><pubDate>Fri, 25 Jul 2025 06:39:05 GMT</pubDate></item><item><title><![CDATA[0028: Find the Index of the First Occurrence in a String]]></title><description><![CDATA[class Solution: def strStr(self, haystack, needle): return haystack.find(needle)
More sophisticated algorithms are there to perform string matching mentioned in the below list:
Knuth-Morris-Pratt (KMP) Algorithm
Boyer-Moore Algorithm
Rabin-Karp Algorithm
]]></description><link>leetcode-solutions/all-solutions/0028-find-the-index-of-the-first-occurrence-in-a-string.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0028-Find the Index of the First Occurrence in a String.md</guid><pubDate>Wed, 23 Jul 2025 12:16:02 GMT</pubDate></item><item><title><![CDATA[0009: Palindrome Number]]></title><description><![CDATA[class Solution: def isPalindrome(self, x: int) -&gt; bool: s = str(x) lx = 0 rx = len(s) - 1 while lx &lt; rx and s[lx] == s[rx]: lx = lx + 1 rx = rx - 1 return lx &gt;= rx
]]></description><link>leetcode-solutions/all-solutions/0009-palindrome-number.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0009-Palindrome Number.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0010: Regular Expression Matching]]></title><description><![CDATA[class Solution: def isMatch(self, s: str, p: str) -&gt; bool: @cache def rec(sx, px): # if pattern ends, string must end too if px &gt;= len(p): return sx == len(s) # check if prefix `can_match`: can_match = sx &lt; len(s) and p[px] in {s[sx], '.'} # --------------------------------- # next_char == '*': # return `take_it` or `skip_it` # --------------------------------- if px &lt; len(p) - 1 and p[px + 1] == '*': take_it = can_match and rec(sx + 1, px) skip_it = rec(sx, px + 2) return take_it or skip_it # ---------------- # next_char != '*' # ---------------- else: return can_match and rec(sx + 1, px + 1) return False return rec(0, 0)
]]></description><link>leetcode-solutions/all-solutions/0010-regular-expression-matching.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0010-Regular Expression Matching.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0018: 4Sum]]></title><description><![CDATA[class Solution: def fourSum(self, nums, target): if len(nums) &lt; 4: return [] nums.sort() N = len(nums) result = [] for x1 in range(0, N, 1): if x1 &gt; 0 and nums[x1 - 1] == nums[x1]: continue for x2 in range(1 + x1, N, 1): if x2 &gt; 1 + x1 and nums[x2 - 1] == nums[x2]: continue x3 = x2 + 1 x4 = N - 1 while x3 &lt; x4: S = nums[x1] + nums[x2] + nums[x3] + nums[x4] if S &lt; target: while x3 &lt; x4 and nums[x3] == nums[1 + x3]: x3 = x3 + 1 x3 = x3 + 1 elif S &gt; target: while x3 &lt; x4 and nums[x4 - 1] == nums[x4]: x4 = x4 - 1 x4 = x4 - 1 else: result.append([nums[x1], nums[x2], nums[x3], nums[x4]]) while x3 &lt; x4 and nums[x3] == nums[1 + x3]: x3 = x3 + 1 x3 = x3 + 1 return result
]]></description><link>leetcode-solutions/all-solutions/0018-4sum.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0018-4Sum.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0024: Swap Nodes in Pairs]]></title><description><![CDATA[class Solution: def swapPairs(self, head): dummy = ListNode(0, head) it = dummy while it and it.next and it.next.next: first = it.next second = it.next.next first.next = second.next second.next = first it.next = second it = it.next.next return dummy.next
]]></description><link>leetcode-solutions/all-solutions/0024-swap-nodes-in-pairs.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0024-Swap Nodes in Pairs.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0053: Maximum Subarray]]></title><description><![CDATA[class Solution: def maxSubArray(self, arr): csum = 0 cmax = max(arr) for ix, n in enumerate(arr): csum = csum + n cmax = max(cmax, csum) if csum &lt; 0: csum = 0 return cmax
]]></description><link>leetcode-solutions/all-solutions/0053-maximum-subarray.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0053-Maximum Subarray.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0076: Minimum Window Substring]]></title><description><![CDATA[from collections import Counter class Solution: def minWindow(self, s, t): tgt = Counter(t) lx = 0 src = {} cmin = 1e9 out = "" for rx, c in enumerate(s): src[c] = src.get(c, 0) + 1 while all([src.get(cc, 0) &gt;= tgt[cc] for cc in t]): if cmin &gt; rx - lx + 1: cmin = rx - lx + 1 out = s[lx:rx + 1] src[s[lx]] -= 1 lx = lx + 1 return out
]]></description><link>leetcode-solutions/all-solutions/0076-minimum-window-substring.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0076-Minimum Window Substring.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0121: Best Time to Buy and Sell Stock]]></title><description><![CDATA[class Solution: def maxProfit(self, prices): maxp = 0 cmin = float('inf') for p in prices: maxp = max(maxp, p - cmin) cmin = min(cmin, p) return maxp
]]></description><link>leetcode-solutions/all-solutions/0121-best-time-to-buy-and-sell-stock.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0121-Best Time to Buy and Sell Stock.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0435: Non-overlapping Intervals]]></title><description><![CDATA[class Solution: def eraseOverlapIntervals(self, intervals): intervals.sort(key=lambda x: (x[1], x[0])) count = 0 prev = intervals[0] for ix in range(1, len(intervals)): curr = intervals[ix] if prev[1] &gt; curr[0]: count = count + 1 continue prev = curr return count
]]></description><link>leetcode-solutions/all-solutions/0435-non-overlapping-intervals.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0435-Non-overlapping Intervals.md</guid><pubDate>Wed, 23 Jul 2025 06:32:13 GMT</pubDate></item><item><title><![CDATA[0001: Two Sum]]></title><description><![CDATA[class Solution: def twoSum(self, nums, target): rec = {} for ix, n in enumerate(nums): if n not in rec: rec[target - n] = ix continue return [ix, rec[n]] return [-1, -1]
]]></description><link>leetcode-solutions/all-solutions/0001-two-sum.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0001-Two Sum.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0002: Add Two Numbers]]></title><description><![CDATA[class Solution: def addTwoNumbers(self, l1, l2): result = temp = ListNode(-1, None) carry = 0 while l1 or l2: n1 = 0 if not l1 else l1.val n2 = 0 if not l2 else l2.val total = n1 + n2 + carry carry = total // 10 total = total % 10 temp.next = ListNode(total) temp = temp.next l1 = None if not l1 else l1.next l2 = None if not l2 else l2.next if carry: temp.next = ListNode(carry) temp = temp.next return result.next
]]></description><link>leetcode-solutions/all-solutions/0002-add-two-numbers.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0002-Add Two Numbers.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0003: Longest Substring Without Repeating Characters]]></title><description><![CDATA[class Solution: def lengthOfLongestSubstring(self, s): lx = 0 cmax = 0 cache = {} for rx, c in enumerate(s): # only look in current window: if c in cache and cache[c] &gt;= lx: lx = cache[c] + 1 cache[c] = rx cmax = max(cmax, rx - lx + 1) return cmax
]]></description><link>leetcode-solutions/all-solutions/0003-longest-substring-without-repeating-characters.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0003-Longest Substring Without Repeating Characters.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0004: Median of Two Sorted Arrays]]></title><description><![CDATA[class Solution: def findMedianSortedArrays(self, nums1, nums2): # keep smaller array above: if len(nums1) &gt; len(nums2): nums1, nums2 = nums2, nums1 # get lengths of above and below arrays: nU, nL = len(nums1), len(nums2) lx, rx = 0, nU while lx &lt;= rx: # get partitions: px_u = (lx + rx) // 2 px_l = (nU + nL + 1) // 2 - px_u # [...] - [&lt;px_u&gt;, ...] ul_max = float('-inf') if px_u == 0 else nums1[px_u - 1] ur_min = float('+inf') if px_u == nU else nums1[px_u] # [...] - [&lt;px_l&gt;, ...] ll_max = float('-inf') if px_l == 0 else nums2[px_l - 1] lr_min = float('+inf') if px_l == nL else nums2[px_l] # if already in equilibrium: if ul_max &lt;= lr_min and ur_min &gt;= ll_max: if (nL + nU) % 2 == 0: return (max(ul_max, ll_max) + min(ur_min, lr_min)) / 2 else: return max(ul_max, ll_max) # not in equilibrium: elif ul_max &gt; lr_min: rx = px_u - 1 else: lx = px_u + 1 return -1
]]></description><link>leetcode-solutions/all-solutions/0004-median-of-two-sorted-arrays.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0004-Median of Two Sorted Arrays.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0005: Longest Palindromic Substring]]></title><description><![CDATA[class Solution: def longestPalindrome(self, s): N = len(s) cmax = 0 output = "" for ix in range(N): lx = rx = ix while lx &gt;= 0 and rx &lt; N and s[lx] == s[rx]: if cmax &lt; rx - lx + 1: output = s[lx:1 + rx] cmax = rx - lx + 1 lx = lx - 1 rx = rx + 1 for ix in range(N - 1): lx = ix rx = ix + 1 while lx &gt;= 0 and rx &lt; N and s[lx] == s[rx]: if cmax &lt; rx - lx + 1: output = s[lx:1 + rx] cmax = rx - lx + 1 lx = lx - 1 rx = rx + 1 return output
]]></description><link>leetcode-solutions/all-solutions/0005-longest-palindromic-substring.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0005-Longest Palindromic Substring.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0006: Zigzag Conversion]]></title><description><![CDATA[class Solution: def convert(self, s, numRows): if numRows == 1: return s out = [[] for ix in range(numRows)] px = 0 reverse = True for cx, c in enumerate(s): if px == 0 or px == numRows - 1: reverse = not reverse out[px].append(c) px = px + (1 if not reverse else -1) return "".join(["".join(o) for o in out])
]]></description><link>leetcode-solutions/all-solutions/0006-zigzag-conversion.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0006-Zigzag Conversion.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0007: Reverse Integer]]></title><description><![CDATA[class Solution: def reverse(self, x: int) -&gt; int: # record the sign sign = -1 if x &lt; 0 else +1 # set limits without overflowing the values limit = 2 ** 30 + ((2 ** 30) - 1) if sign == +1 else 2 ** 31 x = abs(x) cnum = 0 while x: # look ahead if overflow can happen if cnum &gt; limit // 10: return 0 # corner case for overflow comparing last digit if cnum == limit // 10 and (x % 10 &gt; limit % 10): return 0 # update the value: cnum = cnum * 10 + (x % 10) x = x // 10 return sign * cnum
]]></description><link>leetcode-solutions/all-solutions/0007-reverse-integer.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0007-Reverse Integer.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0008: String to Integer (atoi)]]></title><description><![CDATA[class Solution: def myAtoi(self, s: str) -&gt; int: ix = 0 N = len(s) # remove whitespaces while ix &lt; N and s[ix] == ' ': ix = ix + 1 sign = +1 # infer sign if ix &lt; N and s[ix] in {'+', '-'}: sign = (+1 if s[ix] == '+' else -1) ix = ix + 1 # read max non-digits out = 0 while ix &lt; N: if not s[ix].isdigit(): break out = out * 10 + int(s[ix]) ix = ix + 1 # clamp and return number return min(max(sign * out, -(2 ** 31)), (2 ** 31) - 1)
]]></description><link>leetcode-solutions/all-solutions/0008-string-to-integer-(atoi).html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0008-String to Integer (atoi).md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0011: Container With Most Water]]></title><description><![CDATA[class Solution: def maxArea(self, height): N = len(height) lx, rx = 0, N - 1 cmax = 0 while lx &lt; rx: if height[lx] &lt;= height[rx]: minH = min(height[lx], height[rx]) cmax = max(cmax, minH * (rx - lx)) lx = lx + 1 else: minH = min(height[lx], height[rx]) cmax = max(cmax, minH * (rx - lx)) rx = rx - 1 return cmax
]]></description><link>leetcode-solutions/all-solutions/0011-container-with-most-water.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0011-Container With Most Water.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0012: Integer to Roman]]></title><description><![CDATA[class Solution: def intToRoman(self, num): keys = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] vals = [ 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I' ] cache = dict(zip(keys, vals)) ix = 0 out = [] while num: while num &lt; keys[ix]: ix = ix + 1 num = num - keys[ix] out.append(vals[ix]) return "".join(out)
]]></description><link>leetcode-solutions/all-solutions/0012-integer-to-roman.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0012-Integer to Roman.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0013: Roman to Integer]]></title><description><![CDATA[class Solution: def romanToInt(self, s): valmap = { 'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000 } lx = 0 total = 0 while lx &lt; len(s): found_prefix = False # two char prefix: for pre in ['CM', 'CD', 'XC', 'XL', 'IX', 'IV']: if s[lx::].startswith(pre): total = total + valmap[pre] lx = lx + len(pre) found_prefix = True break # one char prefix: if not found_prefix and lx &lt; len(s): total = total + valmap[s[lx]] lx = lx + 1 return total
]]></description><link>leetcode-solutions/all-solutions/0013-roman-to-integer.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0013-Roman to Integer.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0014: Longest Common Prefix]]></title><description><![CDATA[class Solution: def longestCommonPrefix(self, strs): smin = min(strs, key=len) for ix, c in enumerate(smin): if len(set([s[ix] for s in strs])) != 1: return smin[:ix] return smin
]]></description><link>leetcode-solutions/all-solutions/0014-longest-common-prefix.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0014-Longest Common Prefix.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0015: 3Sum]]></title><description><![CDATA[class Solution: def threeSum(self, nums): N = len(nums) nums.sort() res = [] for ix in range(N - 2): if ix &gt; 0 and nums[ix - 1] == nums[ix]: continue jx = 1 + ix kx = N - 1 while jx &lt; kx: s = nums[ix] + nums[jx] + nums[kx] if s &lt; 0: while jx &lt; kx and nums[jx] == nums[jx + 1]: jx = jx + 1 jx = jx + 1 elif s &gt; 0: while jx &lt; kx and nums[kx] == nums[kx - 1]: kx = kx - 1 kx = kx - 1 else: res.append([ nums[ix], nums[jx], nums[kx] ]) while jx &lt; kx and nums[kx] == nums[kx - 1]: kx = kx - 1 kx = kx - 1 return res
]]></description><link>leetcode-solutions/all-solutions/0015-3sum.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0015-3Sum.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0016: 3Sum Closest]]></title><description><![CDATA[class Solution: def threeSumClosest(self, nums, target): nums.sort() cmin = float('inf') for ix in range(len(nums) - 2): lx = ix + 1 rx = len(nums) - 1 while lx &lt; rx: s = nums[ix] + nums[lx] + nums[rx] if s == target: return s cmin = min(cmin, s, key=lambda x: abs(target - x)) if s &lt;= target: lx += 1 else: rx -= 1 return cmin
]]></description><link>leetcode-solutions/all-solutions/0016-3sum-closest.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0016-3Sum Closest.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0017: Letter Combinations of a Phone Number]]></title><description><![CDATA[class Solution: def letterCombinations(self, digits): cmap = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def btrack(ix, buf, res): if ix == len(digits): if buf: res.append("".join(buf)) return for c in cmap[digits[ix]]: buf.append(c) btrack(ix + 1, buf, res) buf.pop() result = [] btrack(0, [], result) return result
]]></description><link>leetcode-solutions/all-solutions/0017-letter-combinations-of-a-phone-number.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0017-Letter Combinations of a Phone Number.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0019: Remove Nth Node From End of List]]></title><description><![CDATA[class Solution: def removeNthFromEnd(self, head, n): temp = head for ix in range(n): temp = temp.next if not temp: return head.next curr = head while temp and temp.next: curr = curr.next temp = temp.next curr.next = curr.next.next return head
]]></description><link>leetcode-solutions/all-solutions/0019-remove-nth-node-from-end-of-list.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0019-Remove Nth Node From End of List.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0020: Valid Parentheses]]></title><description><![CDATA[class Solution: def isValid(self, s): stk = [] for cx, c in enumerate(s): if c in '[{(': stk.append(c) continue if c == ')' and stk and stk[-1] == '(': stk.pop() continue if c == ']' and stk and stk[-1] == '[': stk.pop() continue if c == '}' and stk and stk[-1] == '{': stk.pop() continue return False return len(stk) == 0
]]></description><link>leetcode-solutions/all-solutions/0020-valid-parentheses.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0020-Valid Parentheses.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0021: Merge Two Sorted Lists]]></title><description><![CDATA[class Solution: def mergeTwoLists(self, list1, list2): dummy = ListNode(0) temp = dummy while list1 or list2: v1 = float('inf') if not list1 else list1.val v2 = float('inf') if not list2 else list2.val if v1 &gt; v2: temp.next = ListNode(v2) list2 = None if not list2 else list2.next else: temp.next = ListNode(v1) list1 = None if not list1 else list1.next temp = temp.next return dummy.next
]]></description><link>leetcode-solutions/all-solutions/0021-merge-two-sorted-lists.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0021-Merge Two Sorted Lists.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0022: Generate Parenthesis]]></title><description><![CDATA[class Solution: def generateParenthesis(self, n): def generate(ob, cb, buf, output): if cb &gt; ob: return if len(buf) == 2 * n: output.append("".join(buf)) return if ob &lt; n: buf.append('(') generate(ob + 1, cb, buf, output) buf.pop() buf.append(')') generate(ob, cb + 1, buf, output) buf.pop() result = [] generate(0, 0, [], result) return result
]]></description><link>leetcode-solutions/all-solutions/0022-generate-parentheses.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0022-Generate Parentheses.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0023: Merge k Sorted Lists]]></title><description><![CDATA[import heapq class CustomNode: def __init__(self, node): self.node = node def __lt__(self, other): return self.node.val &lt; other.node.val class Solution: def mergeKLists(self, lists): hq = [] for l in lists: if not l: continue heapq.heappush(hq, CustomNode(l)) dummy = temp = ListNode(0) while hq: curr_node = heapq.heappop(hq) temp.next = ListNode(curr_node.node.val) temp = temp.next next_node = curr_node.node.next if next_node: heapq.heappush(hq, CustomNode(next_node)) return dummy.next
]]></description><link>leetcode-solutions/all-solutions/0023-merge-k-sorted-lists.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0023-Merge k Sorted Lists.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0025: Reverse Nodes in k-Group]]></title><description><![CDATA[class Solution: def reverseKGroup(self, head, k): def revk(node, k): prev = None curr = node while curr and k &gt; 0: temp = curr.next curr.next = prev prev = curr curr = temp k = k - 1 return prev, curr, k == 0 dummy = ListNode(0) temp = dummy while head: done, head, completed = revk(head, k) temp.next = done if completed else revk(done, k)[0] while temp and temp.next: temp = temp.next return dummy.next
]]></description><link>leetcode-solutions/all-solutions/0025-reverse-nodes-in-k-group.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0025-Reverse Nodes in k-Group.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0026: Remove Duplicates from Sorted Array]]></title><description><![CDATA[class Solution: def removeDuplicates(self, nums): N = len(nums) write_head = 0 for read_head in range(N): if read_head &gt; 0 and nums[read_head] == nums[read_head - 1]: continue nums[write_head] = nums[read_head] write_head = write_head + 1 return write_head
]]></description><link>leetcode-solutions/all-solutions/0026-remove-duplicates-from-sorted-array.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0026-Remove Duplicates from Sorted Array.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0027: Remove Element]]></title><description><![CDATA[class Solution: def removeElement(self, nums, val): N = len(nums) write_head = 0 for read_head in range(N): if nums[read_head] == val: continue nums[write_head] = nums[read_head] write_head = write_head + 1 return write_head
]]></description><link>leetcode-solutions/all-solutions/0027-remove-element.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0027-Remove Element.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0029: Divide Two Integers]]></title><description><![CDATA[class Solution: def divide(self, dividend, divisor): MIN_VAL, MAX_VAL = -(2 ** 31), +(2 ** 31 - 1) if dividend == MIN_VAL and divisor == -1: return MAX_VAL sign = -1 if (dividend &lt; 0) ^ (divisor &lt; 0) else +1 dividend = abs(dividend) divisor = abs(divisor) quotient = 0 for ix in range(31, -1, -1): subtrahend = (divisor &lt;&lt; ix) if dividend &gt;= subtrahend: dividend = dividend - subtrahend quotient = quotient + (1 &lt;&lt; ix) return -quotient if sign == -1 else quotient
]]></description><link>leetcode-solutions/all-solutions/0029-divide-two-integers.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0029-Divide Two Integers.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0030: Substring with Concatenation of All Words]]></title><description><![CDATA[from collections import Counter class Solution: def findSubstring(self, s, words): N = len(words) L = len(words[0]) if len(s) &lt; N * L: return [] target = Counter(words) def check(s, sid, tgt, N, L): sx = sid buf = [] while sx &lt; sid + N * L: buf.append(s[sx:sx + L]) sx = sx + L return Counter(buf) == tgt results = [] tgt_hash_val = sum([sum(map(ord, word)) for word in words]) src_hash_val = sum(map(ord, s[0:N * L])) for ix in range(len(s) - N * L + 1): if ix != 0: src_hash_val = src_hash_val - ord(s[ix - 1]) src_hash_val = src_hash_val + ord(s[ix + N * L - 1]) if src_hash_val != tgt_hash_val: continue if check(s, ix, target, N, L): results.append(ix) return results
]]></description><link>leetcode-solutions/all-solutions/0030-substring-with-concatenation-of-all-words.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0030-Substring with Concatenation of All Words.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0033: Search in Rotated Sorted Array]]></title><description><![CDATA[class Solution: def search(self, nums, target): def bsearch(arr, lx, rx, target): if lx &lt;= rx: mx = lx + (rx - lx) // 2 if int(arr[mx] &lt; nums[0]) &lt; target: return bsearch(arr, mx + 1, rx, target) else: temp = bsearch(arr, lx, mx - 1, target) if temp == -1: return mx return temp return -1 ix = bsearch(nums, 0, len(nums) - 1, 0.5) ix = ix % len(nums) if ix != -1 else 0 imap = lambda x: (x + ix) % len(nums) N = len(nums) def binsearch(arr, lx, rx, target): if lx &lt;= rx: mx = lx + (rx - lx) // 2 if arr[imap(mx)] == target: return imap(mx) elif arr[imap(mx)] &lt; target: return binsearch(arr, mx + 1, rx, target) else: return binsearch(arr, lx, mx - 1, target) return -1
]]></description><link>leetcode-solutions/all-solutions/0033-search-in-rotated-sorted-array.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0033-Search in Rotated Sorted Array.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0048: Rotate Image]]></title><description><![CDATA[class Solution: def rotate(self, matrix): matrix.reverse() N = len(matrix) for rx in range(N): for cx in range(0, 1 + rx): matrix[rx][cx], matrix[cx][rx] = matrix[cx][rx], matrix[rx][cx]
]]></description><link>leetcode-solutions/all-solutions/0048-rotate-image.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0048-Rotate Image.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0049: Group Anagrams]]></title><description><![CDATA[class Solution: def groupAnagrams(self, strs): cache = {} for sx, s in enumerate(strs): temp = "".join(sorted(s)) if temp not in cache: cache[temp] = [] cache[temp].append(s) return [v for k, v in cache.items()]
]]></description><link>leetcode-solutions/all-solutions/0049-group-anagrams.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0049-Group Anagrams.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0054: Spiral Matrix]]></title><description><![CDATA[class Solution: def spiralOrder(self, matrix): nR = len(matrix) nC = len(matrix[0]) initR = 0 initC = 0 stopR = nR - 1 stopC = nC - 1 out = [] count = 0 while count &lt; nR * nC: if count &lt; nR * nC: for cx in range(initC, stopC + 1, +1): out.append(matrix[initR][cx]) count = count + 1 initR = initR + 1 if count &lt; nR * nC: for rx in range(initR, stopR + 1, +1): out.append(matrix[rx][stopC]) count = count + 1 stopC = stopC - 1 if count &lt; nR * nC: for cx in range(stopC, initC - 1, -1): out.append(matrix[stopR][cx]) count = count + 1 stopR = stopR - 1 if count &lt; nR * nC: for rx in range(stopR, initR - 1, -1): out.append(matrix[rx][initC]) count = count + 1 initC = initC + 1 return out
]]></description><link>leetcode-solutions/all-solutions/0054-spiral-matrix.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0054-Spiral Matrix.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0055: Jump Game]]></title><description><![CDATA[class Solution: def canJump(self, nums): if len(nums) == 1: return True cmax = 0 for ix, n in enumerate(nums): if cmax &gt;= ix: cmax = max(cmax, ix + n) return cmax &gt;= len(nums) - 1
]]></description><link>leetcode-solutions/all-solutions/0055-jump-game.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0055-Jump Game.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0056: Merge Intervals]]></title><description><![CDATA[class Solution: def merge(self, intervals): intervals.sort(key=lambda x: (x[0], x[1])) prev = intervals[0] out = [prev] for ix in range(1, len(intervals)): curr = intervals[ix] if prev[1] &gt;= curr[0]: prev[1] = max(prev[1], curr[1]) continue out.append(curr) prev = curr return out
]]></description><link>leetcode-solutions/all-solutions/0056-merge-intervals.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0056-Merge Intervals.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0057: Insert Interval]]></title><description><![CDATA[class Solution: def insert(self, intervals, newInterval): intervals.append(newInterval) intervals.sort(key=lambda x: (x[0], x[1])) prev = intervals[0] out = [prev] N = len(intervals) for ix in range(1, N): curr = intervals[ix] if prev[1] &gt;= curr[0]: prev[1] = max(prev[1], curr[1]) continue out.append(curr) prev = curr return out
]]></description><link>leetcode-solutions/all-solutions/0057-insert-interval.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0057-Insert Interval.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0073: Set Matrix Zeroes]]></title><description><![CDATA[class Solution: def setZeroes(self, matrix): nR = len(matrix) nC = len(matrix[0]) hasRow0 = False hasCol0 = False m = matrix for rx in range(nR): if m[rx][0] == 0: hasCol0 = True for cx in range(nC): if m[0][cx] == 0: hasRow0 = True for rx in range(1, nR): for cx in range(1, nC): if m[rx][cx] == 0: m[0][cx] = 0 m[rx][0] = 0 for rx in range(1, nR): if m[rx][0] == 0: for cx in range(1, nC): m[rx][cx] = 0 for cx in range(1, nC): if m[0][cx] == 0: for rx in range(1, nR): m[rx][cx] = 0 if hasRow0: for cx in range(nC): m[0][cx] = 0 if hasCol0: for rx in range(nR): m[rx][0] = 0
]]></description><link>leetcode-solutions/all-solutions/0073-set-matrix-zeroes.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0073-Set Matrix Zeroes.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0098: Validate Binary Search Tree]]></title><description><![CDATA[class Solution: def isValidBST(self, root): def rec(node, lmax, rmin): if not node: return True if node.val &lt;= lmax or node.val &gt;= rmin: return False return rec(node.left, lmax, node.val) and rec(node.right, node.val, rmin) return rec(root, float('-inf'), float('+inf'))
]]></description><link>leetcode-solutions/all-solutions/0098-validate-binary-search-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0098-Validate Binary Search Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0100: Same Tree]]></title><description><![CDATA[class Solution: def isSameTree(self, p, q): def rec(n1, n2): if not n1 and not n2: return True if n1 and not n2: return False if n2 and not n1: return False return n1.val == n2.val and rec(n1.left, n2.left) and rec(n1.right, n2.right) return rec(p, q)
]]></description><link>leetcode-solutions/all-solutions/0100-same-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0100-Same Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0102: Binary Tree Level Order Traversal]]></title><description><![CDATA[from collections import deque class Solution: def levelOrder(self, root): if not root: return [] dq = deque([root]) out = [] while dq: N = len(dq) temp = [] for _ in range(N): curr = dq.popleft() temp.append(curr.val) if curr.left: dq.append(curr.left) if curr.right: dq.append(curr.right) out.append(temp) return out
]]></description><link>leetcode-solutions/all-solutions/0102-binary-tree-level-order-traversal.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0102-Binary Tree Level Order Traversal.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0104: Maximum Depth of Binary Tree]]></title><description><![CDATA[class Solution: def maxDepth(self, root): def rec(node): if not node: return 0 return 1 + max(rec(node.left), rec(node.right)) return rec(root) if root else 0
]]></description><link>leetcode-solutions/all-solutions/0104-maximum-depth-of-binary-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0104-Maximum Depth of Binary Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0105: Construct Binary Tree from Preorder and Inorder Traversal]]></title><description><![CDATA[class Solution: def buildTree(self, preorder, inorder): def rec(po, io): if not po: return None ix = io.index(po[0]) return TreeNode( po[0], rec(po[1:1+ix], io[0:ix]), rec(po[1+ix:], io[1+ix:]) ) return rec(preorder, inorder)
]]></description><link>leetcode-solutions/all-solutions/0105-construct-binary-tree-from-preorder-and-inorder-traversal.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0105-Construct Binary Tree from Preorder and Inorder Traversal.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0124: Binary Tree Maximum Path Sum]]></title><description><![CDATA[class Solution: def maxPathSum(self, root): cmax = float('-inf') def rec(node): nonlocal cmax if not node: return 0 lsum = max(0, rec(node.left)) rsum = max(0, rec(node.right)) cmax = max(cmax, node.val + lsum + rsum) return node.val + max(lsum, rsum) rec(root) return cmax
]]></description><link>leetcode-solutions/all-solutions/0124-binary-tree-maximum-path-sum.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0124-Binary Tree Maximum Path Sum.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0125: Valid Palindrome]]></title><description><![CDATA[class Solution: def isPalindrome(self, s): s = s.lower() s = list(filter(lambda x: x.isalnum(), list(s))) return s == s[::-1]
]]></description><link>leetcode-solutions/all-solutions/0125-valid-palindrome.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0125-Valid Palindrome.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0128: Longest Consecutive Sequence]]></title><description><![CDATA[class Solution: def longestConsecutive(self, nums): rec = set(nums) cmax = 0 for n in nums: if n - 1 in rec: continue temp = 1 while n + 1 in rec: temp = temp + 1 n = n + 1 cmax = max(cmax, temp) return cmax
]]></description><link>leetcode-solutions/all-solutions/0128-longest-consecutive-sequence.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0128-Longest Consecutive Sequence.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0133: Clone Graph]]></title><description><![CDATA["""
# Definition for a Node.
class Node: def __init__(self, val = 0, neighbors = None): self.val = val self.neighbors = neighbors if neighbors is not None else []
""" class Solution: def cloneGraph(self, node): vset = {} def dfs(root): if not root: return None vset[root] = Node(root.val, []) for adj in root.neighbors: if adj not in vset: vset[adj] = dfs(adj) vset[root].neighbors.append(vset[adj]) return vset[root] return dfs(node)
]]></description><link>leetcode-solutions/all-solutions/0133-clone-graph.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0133-Clone Graph.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0143: Reorder List]]></title><description><![CDATA[class Solution: def reorderList(self, head): if not head: return None lsl = head rsl = None slow = head fast = head.next while slow and fast and fast.next: fast = fast.next.next slow = slow.next rsl = slow.next slow.next = None def rec(node): prev = None curr = node while curr: temp = curr.next curr.next = prev prev = curr curr = temp return prev rsl = rec(rsl) lptr = lsl while rsl: temp = rsl.next rsl.next = lptr.next lptr.next = rsl lptr = lptr.next.next rsl = temp return lsl
]]></description><link>leetcode-solutions/all-solutions/0143-reorder-list.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0143-Reorder List.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0153: Find Minimum in Rotated Sorted Array]]></title><description><![CDATA[import bisect class Solution: def findMin(self, nums): def bsearch(arr, lx, rx, target): if lx &lt;= rx: mx = lx + (rx - lx) // 2 if int(arr[mx] &lt; nums[0]) &lt; target: return bsearch(arr, mx + 1, rx, target) else: temp = bsearch(arr, lx, mx - 1, target) if temp == -1: return mx return temp return -1 ix = bsearch(nums, 0, len(nums) - 1, 0.5) if ix == -1: return nums[0] return nums[ix % len(nums)]
]]></description><link>leetcode-solutions/all-solutions/0153-find-minimum-in-rotated-sorted-array.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0153-Find Minimum in Rotated Sorted Array.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0191: Number of 1 Bits]]></title><description><![CDATA[class Solution: def hammingWeight(self, n): count = 0 while n: count += n % 2 n //= 2 return count
]]></description><link>leetcode-solutions/all-solutions/0191-number-of-1-bits.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0191-Number of 1 Bits.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0200: Number of Islands]]></title><description><![CDATA[from collections import deque class Solution: def numIslands(self, grid): nR = len(grid) nC = len(grid[0]) def bfs(rx, cx, vset): dq = deque([(rx, cx)]) vset.add((rx, cx)) while dq: rr, cc = dq.popleft() for dr, dc in [(0, 1), (1, 0), (-1, 0), (0, -1)]: nr = rr + dr nc = cc + dc if 0 &lt;= nr &lt; nR and 0 &lt;= nc &lt; nC: if grid[nr][nc] == "1" and (nr, nc) not in vset: vset.add((nr, nc)) dq.append((nr, nc)) count = 0 cache = set() for ir in range(nR): for ic in range(nC): if grid[ir][ic] == "1" and (ir, ic) not in cache: bfs(ir, ic, cache) count = count + 1 return count
]]></description><link>leetcode-solutions/all-solutions/0200-number-of-islands.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0200-Number of Islands.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0206: Reverse Linked List]]></title><description><![CDATA[class Solution: def reverseList(self, head): def rev(node): prev = None curr = node while curr: temp = curr.next curr.next = prev prev = curr curr = temp return prev return rev(head)
]]></description><link>leetcode-solutions/all-solutions/0206-reverse-linked-list.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0206-Reverse Linked List.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0207: Course Schedule]]></title><description><![CDATA[from collections import deque class Solution: def canFinish(self, numCourses, prerequisites): G = {ix: [] for ix in range(numCourses)} P = {ix: 0 for ix in range(numCourses)} for pr in prerequisites: v, u = pr[0], pr[1] G[u].append(v) P[v] = P[v] + 1 iset = [] for ix in P: if P[ix] == 0: iset.append(ix) dq = deque(iset) vset = set(iset) count = 0 while dq: curr = dq.popleft() count = count + 1 for adj in G[curr]: P[adj] = P[adj] - 1 if P[adj] == 0: if adj not in vset: vset.add(adj) dq.append(adj) return count == numCourses
]]></description><link>leetcode-solutions/all-solutions/0207-course-schedule.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0207-Course Schedule.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0208: Implement Trie (Prefix Tree)]]></title><description><![CDATA[class TNode: def __init__(self, val): self.val = val self.end = False self.children = {} class Trie: def __init__(self): self.root = TNode('') def insert(self, word): temp = self.root for cx, c in enumerate(word): if c not in temp.children: temp.children[c] = TNode(c) temp = temp.children[c] temp.end = True def search(self, word): temp = self.root for c in word: if c not in temp.children: return False temp = temp.children[c] return temp.end def startsWith(self, prefix): temp = self.root for c in prefix: if c not in temp.children: return False temp = temp.children[c] return True
]]></description><link>leetcode-solutions/all-solutions/0208-implement-trie-(prefix-tree).html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0208-Implement Trie (Prefix Tree).md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0211: Design Add and Search Words Data Structure]]></title><description><![CDATA[class TrieNode: def __init__(self, val): self.val = val self.end = False self.children = {} class WordDictionary: def __init__(self): self.root = TrieNode('') def addWord(self, word): temp = self.root for cx, c in enumerate(word): if c not in temp.children: temp.children[c] = TrieNode(c) temp = temp.children[c] temp.end = True def search(self, word): def rec_search(wx, word, init_node): wlen = len(word) temp = init_node for cx in range(wx, wlen): c = word[cx] if c == '.': flag = False for cc in temp.children: flag = flag or rec_search(1 + cx, word, temp.children[cc]) return flag if c not in temp.children: return False temp = temp.children[c] return temp.end return rec_search(0, word, self.root)
]]></description><link>leetcode-solutions/all-solutions/0211-design-add-and-search-words-data-structure.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0211-Design Add and Search Words Data Structure.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0212: Word Search II]]></title><description><![CDATA[class TrieNode: def __init__(self): self.children = {} self.end = False def addWord(self, word): temp = self for cx, c in enumerate(word): if c not in temp.children: temp.children[c] = TrieNode() temp = temp.children[c] temp.end = True class Solution: def findWords(self, board, words): root = TrieNode() for word in words: root.addWord(word) nR = len(board) nC = len(board[0]) res = set() visit = set() def dfs(rx, cx, node, word): if 0 &lt;= rx &lt; nR and 0 &lt;= cx &lt; nC and (rx, cx) not in visit and board[rx][cx] in node.children: c = board[rx][cx] word.append(c) visit.add((rx, cx)) node = node.children[c] if node.end: res.add("".join(word)) dfs(rx + 1, cx, node, word) dfs(rx - 1, cx, node, word) dfs(rx, cx + 1, node, word) dfs(rx, cx - 1, node, word) visit.remove((rx, cx)) word.pop() for rx in range(nR): for cx in range(nC): dfs(rx, cx, root, []) return list(res)
]]></description><link>leetcode-solutions/all-solutions/0212-word-search-ii.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0212-Word Search II.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0217: Contains Duplicate]]></title><description><![CDATA[class Solution: def containsDuplicate(self, nums): cache = set() for n in nums: if n in cache: return True cache.add(n) return False
]]></description><link>leetcode-solutions/all-solutions/0217-contains-duplicate.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0217-Contains Duplicate.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0226: Invert Binary Tree]]></title><description><![CDATA[class Solution: def invertTree(self, root): def rec(node): if node: a = node.left b = node.right node.left = b node.right = a rec(node.left) rec(node.right) rec(root) return root
]]></description><link>leetcode-solutions/all-solutions/0226-invert-binary-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0226-Invert Binary Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0230: Kth Smallest Element in a BST]]></title><description><![CDATA[class Solution: def kthSmallest(self, root, k): res = None def rec(node): nonlocal res, k if not node: return rec(node.left) if k == 1: res = node.val k = k - 1 return k = k - 1 rec(node.right) rec(root) return res
]]></description><link>leetcode-solutions/all-solutions/0230-kth-smallest-element-in-a-bst.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0230-Kth Smallest Element in a BST.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0235: Lowest Common Ancestor of a Binary Search Tree]]></title><description><![CDATA[class Solution: def lowestCommonAncestor(self, root, p, q): def rec(node, p, q): if not node or node == p or node == q: return node flagL = rec(node.left, p, q) flagR = rec(node.right, p, q) if flagL and flagR: return node return flagL or flagR return rec(root, p, q)
]]></description><link>leetcode-solutions/all-solutions/0235-lowest-common-ancestor-of-a-binary-search-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0235-Lowest Common Ancestor of a Binary Search Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0238: Product of Array Except Self]]></title><description><![CDATA[class Solution: def productExceptSelf(self, nums): N = len(nums) res = [1] * N prod = 1 for ix in range(0, N, 1): res[ix] *= prod prod *= nums[ix] prod = 1 for ix in range(N - 1, -1, -1): res[ix] *= prod prod *= nums[ix] return res
]]></description><link>leetcode-solutions/all-solutions/0238-product-of-array-except-self.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0238-Product of Array Except Self.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0242: Valid Anagram]]></title><description><![CDATA[from collections import Counter class Solution: def isAnagram(self, s, t): if len(s) != len(t): return False return Counter(s) == Counter(t)
]]></description><link>leetcode-solutions/all-solutions/0242-valid-anagram.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0242-Valid Anagram.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0252: Meeting Rooms]]></title><description><![CDATA[class Solution: def canAttendMeetings(self, intervals): intervals.sort(key=lambda x: (x.start, x.end)) prev = intervals[0] N = len(intervals) for ix in range(1, N): curr = intervals[ix] if prev.end &gt; curr.start: return False prev = curr return True
]]></description><link>leetcode-solutions/all-solutions/0252-meeting-rooms.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0252-Meeting Rooms.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0253: Meeting Rooms II]]></title><description><![CDATA[import heapq class Solution: def minMeetingRooms(self, intervals): intervals.sort(key=lambda x: (x.start, x.end)) hq = [] cmax = 0 for ix, curr in enumerate(intervals): while hq and hq[0][0] &lt;= curr.start: heapq.heappop(hq) heapq.heappush(hq, (curr.end, curr.start)) cmax = max(cmax, len(hq)) return cmax
]]></description><link>leetcode-solutions/all-solutions/0253-meeting-rooms-ii.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0253-Meeting Rooms II.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0261: Graph Valid Tree]]></title><description><![CDATA[from collections import deque class Solution: def validTree(self, n, edges): G = {ix: [] for ix in range(n)} for uv in edges: u, v = uv[0], uv[1] G[u].append(v) G[v].append(u) dq = deque([0]) vset = set([0]) ctr = 0 while dq: curr = dq.popleft() ctr = ctr + 1 for adj in G[curr]: if adj not in vset: vset.add(adj) dq.append(adj) return len(edges) == n - 1 and ctr == n
]]></description><link>leetcode-solutions/all-solutions/0261-graph-valid-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0261-Graph Valid Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0269: Alien Dictionary]]></title><description><![CDATA[from collections import deque class Solution: def foreignDict(self, words): G = {c: set() for c in "".join(words)} P = {c: 0 for c in G} for wx, w2 in enumerate(words): if wx == 0: continue w1 = words[wx - 1] p1 = 0 p2 = 0 while p1 &lt; len(w1) and p2 &lt; len(w2): if w1[p1] == w2[p2]: p1 = p1 + 1 p2 = p2 + 1 else: G[w1[p1]].add(w2[p2]) break for u in G: for v in G[u]: P[v] = P[v] + 1 init = [] for e in P: if P[e] == 0: init.append(e) dq = deque(init) vset = set(init) res = [] while dq: curr = dq.popleft() res.append(curr) for adj in G[curr]: P[adj] -= 1 if P[adj] == 0: vset.add(adj) dq.append(adj) return "".join(res)
]]></description><link>leetcode-solutions/all-solutions/0269-alien-dictionary.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0269-Alien Dictionary.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0271: Encode and Decode Strings]]></title><description><![CDATA[class Solution: def encode(self, strs): out = [] for sx, s in enumerate(strs): N = len(s) out.append(f"{N}#{s}") return "".join(out) def decode(self, s): out = [] while s: ix = s.find('#') clen, cstr = int(s[:ix]), s[1 + ix:] out.append(cstr[0:clen]) s = cstr[clen::] return out
]]></description><link>leetcode-solutions/all-solutions/0271-encode-and-decode-strings.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0271-Encode and Decode Strings.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0297: Serialize and Deserialize Binary Tree]]></title><description><![CDATA[class Solution: def serialize(self, root): res = [] def rec(node): nonlocal res if not node: res.append('x') return res.append(str(node.val)) rec(node.left) rec(node.right) rec(root) return " ".join(res) def deserialize(self, data): def rec(it): v = next(it) if v == 'x': return None cnode = TreeNode( int(v), rec(it), rec(it) ) return cnode temp = iter(data.split()) return rec(temp)
]]></description><link>leetcode-solutions/all-solutions/0297-serialize-and-deserialize-binary-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0297-Serialize and Deserialize Binary Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0323: Number of Connected Components in an Undirected Graph]]></title><description><![CDATA[from collections import deque class Solution: def countComponents(self, n, edges): G = {ix: [] for ix in range(n)} for uv in edges: u, v = uv[0], uv[1] G[u].append(v) G[v].append(u) def bfs(init, vset): vset.add(init) dq = deque([init]) while dq: curr = dq.popleft() for adj in G[curr]: if adj not in vset: vset.add(adj) dq.append(adj) count = 0 cache = set() for ix in range(n): if ix not in cache: bfs(ix, cache) count = count + 1 return count
]]></description><link>leetcode-solutions/all-solutions/0323-number-of-connected-components-in-an-undirected-graph.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0323-Number of Connected Components in an Undirected Graph.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0338: Counting Bits]]></title><description><![CDATA[class Solution: def countBits(self, n): counts = [] for ix in range(1 + n): count = 0 while ix: count += ix % 2 ix //= 2 counts.append(count) return counts
]]></description><link>leetcode-solutions/all-solutions/0338-counting-bits.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0338-Counting Bits.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0371: Sum of Two Integers]]></title><description><![CDATA[class Solution: def getSum(self, a, b): MASK = 0xFFFFFFFF acc = a bfr = b while bfr: carry = ((acc &amp; bfr) &lt;&lt; 1) &amp; MASK sum_without_carry = (acc ^ bfr) &amp; MASK acc = sum_without_carry bfr = carry return acc if acc &lt;= 2 ** 31 - 1 else ~(acc ^ MASK)
]]></description><link>leetcode-solutions/all-solutions/0371-sum-of-two-integers.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0371-Sum of Two Integers.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0417: Pacific Atlantic Water Flow]]></title><description><![CDATA[from collections import deque class Solution: def pacificAtlantic(self, heights): nR = len(heights) nC = len(heights[0]) def bfs(iset): dq = deque(iset) vset = set(iset) cset = set() while dq: rx, cx = dq.popleft() cset.add((rx, cx)) for dr, dc in [(0, 1), (1, 0), (0, -1), (-1, 0)]: rr = rx + dr cc = cx + dc if 0 &lt;= rr &lt; nR and 0 &lt;= cc &lt; nC: if heights[rr][cc] &gt;= heights[rx][cx] and (rr, cc) not in vset: vset.add((rr, cc)) dq.append((rr, cc)) return cset pac = set() atl = set() for rx in range(nR): pac.add((rx, 0)) atl.add((rx, nC - 1)) for cx in range(nC): pac.add((0, cx)) atl.add((nR - 1, cx)) P = bfs(pac) A = bfs(atl) res = P &amp; A
]]></description><link>leetcode-solutions/all-solutions/0417-pacific-atlantic-water-flow.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0417-Pacific Atlantic Water Flow.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0424: Longest Repeating Character Replacement]]></title><description><![CDATA[class Solution: def characterReplacement(self, s, k): lx = 0 maxf = 0 cmax = 0 cache = {} for rx, c in enumerate(s): cache[c] = cache.get(c, 0) + 1 maxf = max(maxf, cache[c]) while (rx - lx + 1) - maxf &gt; k: cache[s[lx]] = cache[s[lx]] - 1 lx = lx + 1 cmax = max(cmax, rx - lx + 1) return cmax
]]></description><link>leetcode-solutions/all-solutions/0424-longest-repeating-character-replacement.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0424-Longest Repeating Character Replacement.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0572: Subtree of Another Tree]]></title><description><![CDATA[class Solution: def isSubtree(self, root, subRoot): def rec(src, tgt): if src and tgt: if rec(src.left, tgt): return True if rec(src.right, tgt): return True return src.val == tgt.val and rec(src.left, tgt.left) and rec(src.right, tgt.right) return src == tgt return rec(root, subRoot)
]]></description><link>leetcode-solutions/all-solutions/0572-subtree-of-another-tree.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0572-Subtree of Another Tree.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0647: Palindromic Substrings]]></title><description><![CDATA[class Solution: def countSubstrings(self, s): N = len(s) count = 0 # odd strings: for ix in range(N): lx = ix rx = ix while lx &gt;= 0 and rx &lt;= N - 1 and s[lx] == s[rx]: lx = lx - 1 rx = rx + 1 count = count + 1 # even strings: for ix in range(N - 1): lx = ix rx = ix + 1 while lx &gt;= 0 and rx &lt;= N - 1 and s[lx] == s[rx]: lx = lx - 1 rx = rx + 1 count = count + 1 return count
]]></description><link>leetcode-solutions/all-solutions/0647-palindromic-substrings.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0647-Palindromic Substrings.md</guid><pubDate>Wed, 23 Jul 2025 06:32:12 GMT</pubDate></item><item><title><![CDATA[0141: Linked List Cycle]]></title><description><![CDATA[class Solution: def hasCycle(self, head): if not head: return False slow = head fast = head.next while slow and fast and fast.next: fast = fast.next.next slow = slow.next if slow == fast: return True return False
]]></description><link>leetcode-solutions/all-solutions/0141-linked-list-cycle.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0141-Linked List Cycle.md</guid><pubDate>Wed, 23 Jul 2025 06:32:11 GMT</pubDate></item><item><title><![CDATA[0295: Find Median from Data Stream]]></title><description><![CDATA[import heapq class MedianFinder: def __init__(self): self.minheap = [] self.maxheap = [] def addNum(self, num): if (not self.maxheap) or (-self.maxheap[0] &gt;= num): heapq.heappush(self.maxheap, -num) else: heapq.heappush(self.minheap, num) if len(self.maxheap) &lt; len(self.minheap): heapq.heappush(self.maxheap, -heapq.heappop(self.minheap)) if len(self.maxheap) - 1 &gt; len(self.minheap): heapq.heappush(self.minheap, -heapq.heappop(self.maxheap)) def findMedian(self): if len(self.minheap) == len(self.maxheap): return (self.minheap[0] - self.maxheap[0]) / 2 return -self.maxheap[0]
]]></description><link>leetcode-solutions/all-solutions/0295-find-median-from-data-stream.html</link><guid isPermaLink="false">LeetCode Solutions/All Solutions/0295-Find Median from Data Stream.md</guid><pubDate>Wed, 23 Jul 2025 06:32:11 GMT</pubDate></item><item><title><![CDATA[Index: System Design]]></title><link>system-design/index.html</link><guid isPermaLink="false">System Design/index.md</guid><pubDate>Wed, 23 Jul 2025 06:32:11 GMT</pubDate></item><item><title><![CDATA[Index: Machine Learning]]></title><description><![CDATA[
<a data-tooltip-position="top" aria-label="HuggingFace - LLM Course" data-href="HuggingFace - LLM Course" href="machine-learning/huggingface-llm-course.html" class="internal-link" target="_self" rel="noopener nofollow">HuggingFace: LLM Course</a>
]]></description><link>machine-learning/index.html</link><guid isPermaLink="false">Machine Learning/index.md</guid><pubDate>Wed, 23 Jul 2025 06:32:08 GMT</pubDate></item></channel></rss>