
## Topic: Arrays

### Fundamentals & Basic Operations

1. `[0001]` Two Sum (Easy)
2. `[0026]` Remove Duplicates from Sorted Array (Easy)
3. `[0027]` Remove Element (Easy)
4. `[0189]` Rotate Array (Medium)
5. `[0121]` Best Time to Buy and Sell Stock (Easy)
6. `[0053]` Maximum Subarray (Easy)
7. `[0118]` Pascal's Triangle (Easy)
8. `[0119]` Pascal's Triangle II (Easy)

### Two Pointers

9.   `[0015]` 3Sum (Medium)
10. `[0016]` 3Sum Closest (Medium)
11. `[0011]` Container With Most Water (Medium)
12. `[0042]` Trapping Rain Water (Hard)
13. `[0283]` Move Zeroes (Easy)
14. `[0977]` Squares of a Sorted Array (Easy)

### Sliding Window

15. `[0003]` Longest Substring Without Repeating Characters (Medium)
16. `[0209]` Minimum Size Subarray Sum (Medium)
17. `[0076]` Minimum Window Substring (Hard)
18. `[0424]` Longest Repeating Character Replacement (Medium)
19. `[1004]` Max Consecutive Ones III (Medium)

### Prefix Sums

20. `[0303]` Range Sum Query - Immutable (Easy)
21. `[0560]` Subarray Sum Equals K (Medium)
22. `[0974]` Subarray Sums Divisible by K (Medium)

### Advanced Array Problems

23. `[0048]` Rotate Image (Medium)
24. `[0054]` Spiral Matrix (Medium)
25. `[0073]` Set Matrix Zeroes (Medium)

## Topic: Strings

### Basic Manipulation

26. `[0344]` Reverse String (Easy)
27. `[0387]` First Unique Character in a String (Easy)
28. `[0242]` Valid Anagram (Easy)
29. `[0020]` Valid Parentheses (Easy)
30. `[0125]` Valid Palindrome (Easy)

### Searching & Matching

31. `[0028]` Find the Index of the First Occurrence in a String (Easy)
32. `[0680]` Valid Palindrome II (Easy)
33. `[0049]` Group Anagrams (Medium)
34. `[0005]` Longest Palindromic Substring (Medium)
35. `[0139]` Word Break (Medium) - *Also DP*

### Advanced String Problems

36. `[0006]` Zigzag Conversion (Medium)
37. `[0008]` String to Integer (atoi) (Medium)
38. `[0151]` Reverse Words in a String (Medium)
39. `[0030]` Substring with Concatenation of All Words (Hard)
40. `[0072]` Edit Distance (Hard) - *Also DP*

## Topic: Linked Lists

### Singly Linked List Operations

41. `[0206]` Reverse Linked List (Easy)
42. `[0021]` Merge Two Sorted Lists (Easy)
43. `[0083]` Remove Duplicates from Sorted List (Easy)
44. `[0019]` Remove Nth Node From End of List (Medium)
45. `[0237]` Delete Node in a Linked List (Medium)

### Cycle Detection & Pointers

46. `[0141]` Linked List Cycle (Easy)
47. `[0142]` Linked List Cycle II (Medium)
48. `[0876]` Middle of the Linked List (Easy)

### Advanced Linked List Problems

49. `[0002]` Add Two Numbers (Medium)
50. `[0061]` Rotate List (Medium)
51. `[0143]` Reorder List (Medium)
52. `[0234]` Palindrome Linked List (Easy)
53. `[0023]` Merge k Sorted Lists (Hard) - *Also Heaps*
54. `[0138]` Copy List with Random Pointer (Medium)
55. `[0328]` Odd Even Linked List (Medium)

## Topic: Stacks & Queues

### Stack Applications

56. `[0020]` Valid Parentheses (Easy) - *Also Strings*
57. `[0155]` Min Stack (Medium)
58. `[0739]` Daily Temperatures (Medium)
59. `[0084]` Largest Rectangle in Histogram (Hard)
60. `[0042]` Trapping Rain Water (Hard) - *Also Arrays, Two Pointers*
61. `[0224]` Basic Calculator (Hard)

### Queue Applications

62. `[0232]` Implement Queue using Stacks (Easy)
63. `[0225]` Implement Stack using Queues (Easy)
64. `[0933]` Number of Recent Calls (Easy)
65. `[0622]` Design Circular Queue (Medium)

## Topic: Hash Tables (Maps / Sets)

### Basic Usage

66. `[0001]` Two Sum (Easy) - *Also Arrays*
67. `[0217]` Contains Duplicate (Easy)
68. `[0387]` First Unique Character in a String (Easy) - *Also Strings*
69. `[0242]` Valid Anagram (Easy) - *Also Strings*
70. `[0049]` Group Anagrams (Medium) - *Also Strings*

### Frequency & Counting

71. `[0350]` Intersection of Two Arrays II (Easy)
72. `[0136]` Single Number (Easy)
73. `[0169]` Majority Element (Easy)
74. `[0290]` Word Pattern (Easy)
75. `[0560]` Subarray Sum Equals K (Medium) - *Also Arrays, Prefix Sums*

### Advanced Hash Table Problems

76. `[0128]` Longest Consecutive Sequence (Medium)
77. `[0347]` Top K Frequent Elements (Medium) - *Also Heaps*
78. `[0454]` 4Sum II (Medium)
79. `[0036]` Valid Sudoku (Medium)
80. `[0146]` LRU Cache (Medium)

## Topic: Trees (Binary Trees & BSTs)

### Binary Tree Traversal (BFS & DFS)

81. `[0094]` Binary Tree Inorder Traversal (Easy)
82. `[0102]` Binary Tree Level Order Traversal (Medium)
83. `[0104]` Maximum Depth of Binary Tree (Easy)
84. `[0101]` Symmetric Tree (Easy)
85. `[0100]` Same Tree (Easy)
86. `[0112]` Path Sum (Easy)
87. `[0105]` Construct Binary Tree from Preorder and Inorder Traversal (Medium)
88. `[0106]` Construct Binary Tree from Inorder and Postorder Traversal (Medium)

### Binary Search Trees (BSTs)

89. `[0098]` Validate Binary Search Tree (Medium)
90. `[0700]` Search in a Binary Search Tree (Easy)
91. `[0701]` Insert into a Binary Search Tree (Medium)
92. `[0450]` Delete Node in a BST (Medium)
93. `[0230]` K-th Smallest Element in a BST (Medium)
94. `[0530]` Minimum Absolute Difference in BST (Easy)

### Tree Properties & Manipulation

95.   `[0226]` Invert Binary Tree (Easy)
96.   `[0110]` Balanced Binary Tree (Easy)
97.   `[0543]` Diameter of Binary Tree (Easy)
98.   `[0236]` Lowest Common Ancestor of a Binary Tree (Medium)
99.   `[0124]` Binary Tree Maximum Path Sum (Hard)
100. `[0297]` Serialize and Deserialize Binary Tree (Hard)
101. `[0114]` Flatten Binary Tree to Linked List (Medium)
102. `[0103]` Binary Tree Zigzag Level Order Traversal (Medium)
103. `[0199]` Binary Tree Right Side View (Medium)
104. `[0617]` Merge Two Binary Trees (Easy)
105. `[0662]` Maximum Width of Binary Tree (Medium)

## Topic: Heaps (Priority Queues)

### Basic Heap Usage

106. `[0215]` K-th Largest Element in an Array (Medium)
107. `[0347]` Top K Frequent Elements (Medium) - *Also Hash Tables*
108. `[0703]` K-th Largest Element in a Stream (Easy)

### Advanced Heap Applications

109. [0023] Merge k Sorted Lists (Hard) - *Also Linked Lists*
110. [0295] Find Median from Data Stream (Hard)
111. [0973] K Closest Points to Origin (Medium)
112. [0480] Sliding Window Median (Hard)
113. [0692] Top K Frequent Words (Medium)
114. [0373] Find K Pairs with Smallest Sums (Medium)
115. [0253] Meeting Rooms II (Medium) - *Premium, but a classic heap problem*

## Topic: Graphs (BFS, DFS, Union-Find, Topological Sort)

### BFS & DFS Fundamentals

116. [0200] Number of Islands (Medium)
117. [0695] Max Area of Island (Medium)
118. [0133] Clone Graph (Medium)
119. [0797] All Paths From Source to Target (Medium)
120. [0547] Number of Provinces (Medium)
121. [0417] Pacific Atlantic Water Flow (Medium)
122. [0994] Rotting Oranges (Medium)
123. [1091] Shortest Path in Binary Matrix (Medium)
### Topological Sort

124. [0207] Course Schedule (Medium)
125. [0210] Course Schedule II (Medium)
126. [0329] Longest Increasing Path in a Matrix (Hard) - *Also DP, DFS with memoization*

### Union-Find

116. [0547] Number of Provinces (Medium) - *Can also be solved with BFS/DFS*
117. [0130] Surrounded Regions (Medium)
118. [0684] Redundant Connection (Medium)
119. [0721] Accounts Merge (Medium)
120. [0959] Regions Cut By Slashes (Hard)

### Advanced Graph Problems

116. [0743] Network Delay Time (Medium) - *Dijkstra's*
117. [0787] Cheapest Flights Within K Stops (Medium) - *Bellman-Ford variant / BFS*
118. [1162] As Far from Land as Possible (Medium) - *Multi-source BFS*
119. [0802] Find Eventual Safe States (Medium) - *DFS / Graph Traversal*
120. [0886] Possible Bipartition (Medium) - *BFS/DFS for Bipartite check*
121. [1584] Min Cost to Connect All Points (Medium) - *Prim's/Kruskal's*
122. [1631] Path With Minimum Effort (Medium) - *Dijkstra's / Binary Search on Answer*
123. [1976] Number of Ways to Arrive at Destination (Medium) - *Dijkstra's variant*
124. [0261] Graph Valid Tree (Medium) - *Premium, but a good graph problem*

## Topic: Recursion & Backtracking

### Basic Recursion

1. [0070] Climbing Stairs (Easy) - *Also DP*
2. [0509] Fibonacci Number (Easy) - *Also DP*
3. [0206] Reverse Linked List (Easy) - *Also Linked Lists*

### Backtracking

### Subsets

1. [0078] Subsets (Medium)
2. [0090] Subsets II (Medium)

### Permutations

3. [0046] Permutations (Medium)
4. [0047] Permutations II (Medium)

### Combinations

5. [0039] Combination Sum (Medium)
6. [0040] Combination Sum II (Medium)
7. [0216] Combination Sum III (Medium)
8. [0017] Letter Combinations of a Phone Number (Medium)

### Exploration Problems

9. [0079] Word Search (Medium)
10. [0051] N-Queens (Hard)
11. [0037] Sudoku Solver (Hard)
12. [0131] Palindrome Partitioning (Medium)

## Topic: Dynamic Programming

### 1-Dimension DP

1. [0070] Climbing Stairs (Easy) - *Also Recursion*
2. [0509] Fibonacci Number (Easy) - *Also Recursion*
3. [0198] House Robber (Medium)
4. [0213] House Robber II (Medium)
5. [0746] Min Cost Climbing Stairs (Easy)
6. [0300] Longest Increasing Subsequence (Medium)
7. [0322] Coin Change (Medium)
8. [0416] Partition Equal Subset Sum (Medium) - *0/1 Knapsack variant*

### 2-Dimension DP

1. [0064] Minimum Path Sum (Medium)
2. [0062] Unique Paths (Medium)
3. [0063] Unique Paths II (Medium)
4. [1143] Longest Common Subsequence (Medium)
5. [0072] Edit Distance (Hard) - *Also Strings*
6. [0516] Longest Palindromic Subsequence (Medium)
7. [0010] Regular Expression Matching (Hard)

### Interval DP / DP on Trees

1. [0312] Burst Balloons (Hard)
2. [0337] House Robber III (Medium)

### Advanced DP Patterns

1. [0139] Word Break (Medium) - *Also Strings*
2. [0152] Maximum Product Subarray (Medium)
3. [0096] Unique Binary Search Trees (Medium)
4. [0120] Triangle (Medium)
5. [0188] Best Time to Buy and Sell Stock IV (Hard)
6. [1048] Longest String Chain (Medium)
7. [1235] Maximum Profit in Job Scheduling (Hard)
8. [1277] Count Square Sub-matrices with All Ones (Medium)

## Topic: Greedy Algorithms

181. [455] Assign Cookies (Easy)
182. [435] Non-overlapping Intervals (Medium)
183. [55] Jump Game (Medium)
184. [45] Jump Game II (Medium)
185. [134] Gas Station (Medium)

## Topic: Binary Search

### Basic Binary Search

1. [704] Binary Search (Easy)
2. [35] Search Insert Position (Easy)

### Binary Search on Answer

1. [33] Search in Rotated Sorted Array (Medium)
2. [153] Find Minimum in Rotated Sorted Array (Medium)
3. [410] Split Array Largest Sum (Hard)

## Topic: Bit Manipulation

191. [191] Number of 1 Bits (Easy)
192. [190] Reverse Bits (Easy)
193. [268] Missing Number (Easy)
194. [136] Single Number (Easy) - *Also Hash Tables*
195. [338] Counting Bits (Medium)

## Topic: Math & Geometry

196. [9] Palindrome Number (Easy)
197. [69] Sqrt(x) (Easy)
198. [50] Pow(x, n) (Medium)
199. [204] Count Primes (Medium)
200. [172] Factorial Trailing Zeroes (Easy)
## Topic: Greedy Algorithms

### Activity Selection / Interval Scheduling

*   [435] Non-overlapping Intervals (Medium)
*   [452] Minimum Number of Arrows to Burst Balloons (Medium)
*   [253] Meeting Rooms II (Medium)
*   [1024] Video Stitching (Medium)

### Fractional Knapsack

*   [1647] Minimum Deletions to Make Character Frequencies Unique (Medium)
*   [1710] Maximum Units on a Truck (Easy)

### Coin Change

*   [322] Coin Change (Medium)

#### 4. Interval Merging / Overlapping Intervals

*   [56] Merge Intervals (Medium)
*   [57] Insert Interval (Medium)

#### 5. Jump Game Variants

*   **Idea:** Determine if you can reach the end, or the minimum jumps to reach the end.
*   **Pattern:** At each step, make the choice that maximizes your reach or minimizes jumps.
*   **LeetCode Examples:**
    *   [55] Jump Game (Medium) - *Can you reach the end? Keep track of the maximum reachable index.*
    *   [45] Jump Game II (Medium) - *Minimum jumps to reach the end. At each jump, find the next jump that maximizes your reach.*

#### 6. Gas Station

*   **Idea:** Find a starting gas station to complete a circular tour.
*   **Pattern:** If the total gas is less than total cost, it's impossible. Otherwise, there's always a solution. Iterate, keeping track of current gas. If current gas drops below zero, reset and try the next station as a start.
*   **LeetCode Examples:**
    *   [134] Gas Station (Medium)

#### 7. Minimum Spanning Tree (Prim's / Kruskal's)

*   **Idea:** Find a subset of edges that connects all vertices with the minimum possible total edge weight, forming a tree.
*   **Pattern:**
    *   **Prim's:** Start from an arbitrary vertex, and at each step, add the cheapest edge that connects a vertex in the MST to a vertex outside the MST. (Often implemented with a min-priority queue).
    *   **Kruskal's:** Sort all edges by weight. Iterate through sorted edges, adding an edge if it connects two previously disconnected components (using Union-Find).
*   **LeetCode Examples:**
    *   [1584] Min Cost to Connect All Points (Medium) - *Classic Kruskal's or Prim's application.*
    *   [1135] Connecting Cities With Minimum Cost (Medium) - *Premium, another direct MST problem.*

#### 8. Dijkstra's Algorithm (Shortest Path on Non-Negative Weights)

*   **Idea:** Find the shortest path from a single source to all other vertices in a graph with non-negative edge weights.
*   **Pattern:** Greedily select the unvisited vertex with the smallest known distance from the source, then update distances to its neighbors. (Implemented with a min-priority queue).
*   **LeetCode Examples:**
    *   [743] Network Delay Time (Medium)
    *   [1631] Path With Minimum Effort (Medium) - *Dijkstra's variant where "cost" is max effort on path.*
    *   [1976] Number of Ways to Arrive at Destination (Medium) - *Dijkstra's variant to count paths.*

---

## II. Dynamic Programming (DP)

**Core Idea:** DP solves complex problems by breaking them down into simpler overlapping subproblems and storing the results of these subproblems to avoid recomputing them.

**When it Works:** DP is applicable when a problem exhibits:
1.  **Optimal Substructure:** An optimal solution to the problem contains optimal solutions to subproblems.
2.  **Overlapping Subproblems:** The same subproblems are encountered multiple times.

**Two Main Approaches:**
*   **Memoization (Top-Down):** Recursive approach where solutions to subproblems are stored in a cache (e.g., hash map or array) as they are computed.
*   **Tabulation (Bottom-Up):** Iterative approach where solutions to subproblems are computed starting from the base cases and building up to the final solution.

---

### Dynamic Programming Sub-Patterns & LeetCode Examples

#### 1. 1D DP (Linear DP)

*   **Idea:** The state `dp[i]` usually depends on `dp[i-1]`, `dp[i-2]`, or a few previous states.
*   **Patterns:**
    *   **Simple Recurrence:** `dp[i] = dp[i-1] + dp[i-2]` (Fibonacci, Climbing Stairs).
    *   **Max/Min over previous states:** `dp[i] = max(dp[i-1], dp[i-2] + current_value)` (House Robber).
    *   **Kadane's Algorithm:** For maximum subarray sum.
*   **LeetCode Examples:**
    *   [70] Climbing Stairs (Easy)
    *   [509] Fibonacci Number (Easy)
    *   [198] House Robber (Medium)
    *   [213] House Robber II (Medium)
    *   [746] Min Cost Climbing Stairs (Easy)
    *   [53] Maximum Subarray (Easy) - *Kadane's Algorithm*
    *   [300] Longest Increasing Subsequence (Medium) - *`dp[i]` is LIS ending at `i`.*
    *   [152] Maximum Product Subarray (Medium) - *Similar to Kadane's, but needs to track min product too.*

#### 2. 2D DP (Grid DP / Matrix DP)

*   **Idea:** The state `dp[i][j]` usually depends on `dp[i-1][j]`, `dp[i][j-1]`, `dp[i-1][j-1]`, or other states in a 2D grid.
*   **Patterns:**
    *   **Path Counting/Min/Max Path:** Moving through a grid.
    *   **Knapsack Variants:** `dp[i][j]` represents the solution for `i` items and `j` capacity.
    *   **String Alignment/Comparison:** `dp[i][j]` for prefixes of two strings.
*   **LeetCode Examples:**
    *   [62] Unique Paths (Medium)
    *   [63] Unique Paths II (Medium)
    *   [64] Minimum Path Sum (Medium)
    *   [1143] Longest Common Subsequence (Medium)
    *   [72] Edit Distance (Hard) - *Levenshtein distance, based on LCS.*
    *   [516] Longest Palindromic Subsequence (Medium) - *Can be derived from LCS.*
    *   [322] Coin Change (Medium) - *Unbounded Knapsack variant, `dp[amount]` is min coins for `amount`.*
    *   [416] Partition Equal Subset Sum (Medium) - *0/1 Knapsack variant.*
    *   [10] Regular Expression Matching (Hard)
    *   [44] Wildcard Matching (Hard)
    *   [1277] Count Square Submatrices with All Ones (Medium)

#### 3. DP on Strings

*   **Idea:** Often involves `dp[i][j]` representing a substring `s[i...j]` or `dp[i]` representing a prefix `s[0...i-1]`.
*   **Patterns:**
    *   **Palindrome related:** Checking for palindromes, partitioning into palindromes.
    *   **Word segmentation:** Breaking a string into valid words.
*   **LeetCode Examples:**
    *   [5] Longest Palindromic Substring (Medium)
    *   [139] Word Break (Medium)
    *   [131] Palindrome Partitioning (Medium) - *Also Backtracking, but DP can optimize.*
    *   [647] Palindromic Substrings (Medium)

#### 4. DP on Trees

*   **Idea:** The state `dp[node]` or `dp[node][state]` depends on the `dp` values of its children. Often solved with DFS.
*   **Patterns:**
    *   **Rooted Tree DP:** Compute values for children first, then combine for parent.
    *   **Rerooting DP:** Solve for an arbitrary root, then re-calculate for all possible roots.
*   **LeetCode Examples:**
    *   [337] House Robber III (Medium)
    *   [124] Binary Tree Maximum Path Sum (Hard)
    *   [968] Binary Tree Cameras (Hard)
    *   [834] Sum of Distances in Tree (Hard) - *Classic rerooting DP.*

#### 5. Interval DP

*   **Idea:** `dp[i][j]` represents the optimal solution for the subproblem defined by the interval `[i, j]`. The solution for `[i, j]` is typically found by considering a split point `k` within `i` and `j`.
*   **Patterns:**
    *   **Matrix Chain Multiplication:** (Conceptual, not direct LeetCode problem usually)
    *   **Merging/Bursting operations:** Problems where operations on an interval affect its neighbors.
*   **LeetCode Examples:**
    *   [312] Burst Balloons (Hard)
    *   [1000] Minimum Cost to Merge Stones (Hard)

#### 6. Bitmask DP / State Compression DP

*   **Idea:** When the number of items or states is small (e.g., up to 20), a bitmask can represent a subset of items or a state. `dp[mask]` stores the solution for the subset represented by `mask`.
*   **Patterns:**
    *   **Traveling Salesperson Problem (TSP) variants:** Visiting all nodes.
    *   **Subset problems:** Where the order of elements in a subset matters or interactions between elements are complex.
*   **LeetCode Examples:**
    *   [698] Partition to K Equal Sum Subsets (Medium) - *Can be solved with backtracking + memoization, or bitmask DP.*
    *   [1125] Smallest Sufficient Team (Hard)
    *   [1434] Number of Ways to Wear Different Hats to Each Other (Hard)
    *   [1349] Maximum Students Taking Exam (Hard)

#### 7. Digit DP

*   **Idea:** Used to count numbers within a range `[L, R]` that satisfy certain properties. It's a recursive function with memoization, typically `solve(index, tight, is_started, ...)` where `tight` indicates if we are restricted by the upper bound of the number.
*   **Patterns:** Counting numbers with specific digit sums, specific digit patterns, etc.
*   **LeetCode Examples:**
    *   [600] Non-negative Integers without Consecutive Ones (Hard)
    *   [902] Numbers At Most N Given Digit Set (Hard)
    *   [233] Number of Digit One (Hard)

---

### Key Differences & When to Use Which

| Feature           | Greedy Algorithms                                  | Dynamic Programming                                     |
| :---------------- | :------------------------------------------------- | :------------------------------------------------------ |
| **Core Idea**     | Make locally optimal choices, hoping for global opt. | Break into overlapping subproblems, store results.       |
| **Decision**      | One-time, irreversible choice at each step.        | Explores all possible choices for subproblems.          |
| **Proof**         | Requires proving the "greedy choice property."     | Relies on "optimal substructure" and "overlapping subproblems." |
| **Complexity**    | Often simpler and faster (polynomial, sometimes linear). | Can be more complex, often polynomial (e.g., O(N^2), O(N*W)). |
| **Applicability** | Limited to problems with specific properties.      | Wider range of problems, especially optimization.        |
| **Example**       | Activity Selection, Dijkstra's, Kruskal's.         | Knapsack, LCS, Coin Change, Path Sum.                   |

**General Rule of Thumb:**
*   **Try Greedy first** if the problem seems to have a straightforward "best choice" at each step. If you can prove the greedy choice property, it's usually the most efficient.
*   **Consider DP** if greedy fails, or if the problem involves finding an optimal value (min/max) and you see overlapping subproblems and optimal substructure. If you need to explore all possibilities to guarantee optimality, DP is likely the way.

Mastering these patterns and understanding their underlying principles will significantly boost your problem-solving capabilities!






========================================================================

Chatbox AI (https://chatboxai.app)